# UI Implementation Plan for Automatic Navigation Variables

Following CLAUDE.md Rule #1 (No dummy implementations) and Rule #3 (Explicit validation with meaningful errors).

**Feature**: Add UI support for automatic `_prev`/`_next` navigation variables that are now generated by the backend for counters and dates.

**Backend Changes Already Completed**:
- ✅ `compilation_service.py` - Auto-generates counter/date navigation variables
- ✅ `token_processor.py` - Returns empty string for missing tokens
- ✅ `link_renderer.py` - Skips link creation for empty destinations

---

## Phase 1: Token Registry Service (Foundation)

**Goal**: Centralized source of truth for available tokens, including automatic `_prev/_next` variants.

### File: `/root/eink/frontend/src/services/tokenRegistry.ts` (NEW)

**Purpose**: Provide complete token catalog with autocomplete data and validation logic.

**Key Features**:
- Complete list of base tokens (date, rendering, sequence)
- Auto-generation of `_prev`/`_next` variants for counters and dates
- Token validation with typo detection (Levenshtein distance)
- Boundary behavior warnings
- Category-based organization for UI

**Implementation**:

```typescript
/**
 * Token registry service for autocomplete and validation.
 * Provides centralized list of available tokens including auto-generated navigation variants.
 * Following CLAUDE.md Rule #1: No dummy implementations - complete token catalog.
 */

export interface TokenInfo {
  name: string;
  description: string;
  example: string;
  category: 'date' | 'counter' | 'navigation' | 'rendering' | 'custom';
  hasNavigation?: boolean; // If true, _prev/_next variants exist
  boundaryBehavior?: string; // Warning about boundary conditions
}

export class TokenRegistry {
  private static baseTokens: TokenInfo[] = [
    // Date tokens (automatic navigation)
    {
      name: 'date',
      description: 'Current date in ISO format (YYYY-MM-DD)',
      example: '2026-01-15',
      category: 'date',
      hasNavigation: true,
      boundaryBehavior: '{date_prev} and {date_next} are automatically available (±1 day)'
    },
    {
      name: 'date_long',
      description: 'Long format date',
      example: 'Wednesday, January 15, 2026',
      category: 'date'
    },
    {
      name: 'year',
      description: 'Current year',
      example: '2026',
      category: 'date',
      hasNavigation: true,
      boundaryBehavior: '{year_prev} and {year_next} are automatically available (±1 year)'
    },
    {
      name: 'month',
      description: 'Month number (1-12)',
      example: '1',
      category: 'date'
    },
    {
      name: 'month_name',
      description: 'Full month name (localized)',
      example: 'January',
      category: 'date'
    },
    {
      name: 'month_abbr',
      description: 'Abbreviated month name',
      example: 'Jan',
      category: 'date'
    },
    {
      name: 'day',
      description: 'Day of month (1-31)',
      example: '15',
      category: 'date'
    },
    {
      name: 'weekday',
      description: 'Weekday name',
      example: 'Wednesday',
      category: 'date'
    },

    // Rendering tokens (page numbers)
    {
      name: 'page',
      description: 'Current PDF page number',
      example: '42',
      category: 'rendering'
    },
    {
      name: 'total_pages',
      description: 'Total number of pages in PDF',
      example: '365',
      category: 'rendering'
    },

    // Sequence tokens
    {
      name: 'index',
      description: 'Current iteration index (1-based)',
      example: '5',
      category: 'custom'
    },
    {
      name: 'index_padded',
      description: 'Zero-padded index (001, 002, ...)',
      example: '005',
      category: 'custom'
    }
  ];

  /**
   * Get all available tokens for a given section configuration.
   * Includes automatic navigation variants for counters and dates.
   */
  static getAvailableTokens(
    counters?: Record<string, { start: number; step: number }>,
    context?: Record<string, any>,
    sectionIndex?: number,
    totalSections?: number
  ): TokenInfo[] {
    const tokens = [...this.baseTokens];

    // Add counter tokens with automatic navigation
    if (counters) {
      Object.entries(counters).forEach(([name, config]) => {
        tokens.push({
          name,
          description: `Counter variable (start: ${config.start}, step: ${config.step})`,
          example: String(config.start),
          category: 'counter',
          hasNavigation: true,
          boundaryBehavior: `{${name}_prev} available when value ≥ start; {${name}_next} available on non-final pages`
        });

        // Add navigation variants explicitly
        tokens.push({
          name: `${name}_prev`,
          description: `Previous value of ${name} (value - step)`,
          example: String(config.start - config.step),
          category: 'navigation',
          boundaryBehavior: 'Empty on first page when value < start'
        });

        tokens.push({
          name: `${name}_next`,
          description: `Next value of ${name} (value + step)`,
          example: String(config.start + config.step),
          category: 'navigation',
          boundaryBehavior: 'Empty on last page'
        });
      });
    }

    // Add context (custom) variables
    if (context) {
      Object.entries(context).forEach(([name, value]) => {
        tokens.push({
          name,
          description: `Custom context variable`,
          example: String(value),
          category: 'custom'
        });
      });
    }

    // Add navigation variants for date tokens
    tokens.push({
      name: 'date_prev',
      description: 'Previous date (date - 1 day)',
      example: '2026-01-14',
      category: 'navigation'
    });

    tokens.push({
      name: 'date_next',
      description: 'Next date (date + 1 day)',
      example: '2026-01-16',
      category: 'navigation'
    });

    tokens.push({
      name: 'year_prev',
      description: 'Previous year (year - 1)',
      example: '2025',
      category: 'navigation'
    });

    tokens.push({
      name: 'year_next',
      description: 'Next year (year + 1)',
      example: '2027',
      category: 'navigation'
    });

    return tokens;
  }

  /**
   * Validate a token string and return helpful error messages.
   * Following CLAUDE.md Rule #3: Explicit validation with meaningful errors.
   */
  static validateToken(
    tokenText: string,
    availableTokens: TokenInfo[]
  ): { valid: boolean; error?: string; warning?: string; suggestion?: TokenInfo } {
    // Extract tokens from text (e.g., "day:{date_next}" → ["date_next"])
    const tokenPattern = /\{([a-zA-Z_][a-zA-Z0-9_-]*)(:[^}]+)?\}/g;
    const matches = Array.from(tokenText.matchAll(tokenPattern));

    if (matches.length === 0) {
      return { valid: true }; // No tokens = valid (plain text)
    }

    const tokenNames = availableTokens.map(t => t.name);

    for (const match of matches) {
      const tokenName = match[1];

      if (!tokenNames.includes(tokenName)) {
        // Find similar tokens (typo detection)
        const similar = this.findSimilarTokens(tokenName, tokenNames);

        return {
          valid: false,
          error: `Unknown token: {${tokenName}}`,
          suggestion: similar.length > 0
            ? availableTokens.find(t => t.name === similar[0])
            : undefined
        };
      }

      // Check boundary warnings for navigation tokens
      const tokenInfo = availableTokens.find(t => t.name === tokenName);
      if (tokenInfo?.boundaryBehavior) {
        return {
          valid: true,
          warning: tokenInfo.boundaryBehavior
        };
      }
    }

    return { valid: true };
  }

  /**
   * Find similar token names using Levenshtein distance (typo detection).
   * Following CLAUDE.md Rule #2: Simple, readable solutions.
   */
  private static findSimilarTokens(input: string, available: string[]): string[] {
    const distances = available.map(token => ({
      token,
      distance: this.levenshteinDistance(input.toLowerCase(), token.toLowerCase())
    }));

    // Return tokens with distance ≤ 2 (1-2 character difference)
    return distances
      .filter(d => d.distance <= 2)
      .sort((a, b) => a.distance - b.distance)
      .map(d => d.token)
      .slice(0, 3);
  }

  private static levenshteinDistance(a: string, b: string): number {
    const matrix: number[][] = [];

    for (let i = 0; i <= b.length; i++) {
      matrix[i] = [i];
    }

    for (let j = 0; j <= a.length; j++) {
      matrix[0][j] = j;
    }

    for (let i = 1; i <= b.length; i++) {
      for (let j = 1; j <= a.length; j++) {
        if (b.charAt(i - 1) === a.charAt(j - 1)) {
          matrix[i][j] = matrix[i - 1][j - 1];
        } else {
          matrix[i][j] = Math.min(
            matrix[i - 1][j - 1] + 1,
            matrix[i][j - 1] + 1,
            matrix[i - 1][j] + 1
          );
        }
      }
    }

    return matrix[b.length][a.length];
  }

  /**
   * Get token category color for UI display.
   */
  static getCategoryColor(category: TokenInfo['category']): string {
    const colors = {
      date: 'text-purple-600 bg-purple-50',
      counter: 'text-blue-600 bg-blue-50',
      navigation: 'text-green-600 bg-green-50',
      rendering: 'text-orange-600 bg-orange-50',
      custom: 'text-gray-600 bg-gray-50'
    };
    return colors[category] || colors.custom;
  }
}
```

**Acceptance Criteria**:
- ✅ Returns complete token list with examples
- ✅ Auto-generates `_prev`/`_next` variants for counters and dates
- ✅ Validates token usage with specific error messages
- ✅ Suggests similar tokens for typos (e.g., `{dat}` → suggest `{date}`)
- ✅ Provides boundary behavior warnings
- ✅ No dummy data - all examples are real

**Estimated Time**: 2 hours

---

## Phase 2: Token Input Component with Validation

**Goal**: Reusable input component with live validation and warnings.

### File: `/root/eink/frontend/src/components/editor/properties/shared/TokenInput.tsx` (NEW)

**Purpose**: Replace plain text inputs with intelligent token-aware inputs.

**Key Features**:
- Live validation as user types
- Autocomplete dropdown grouped by category
- Typo detection with "Did you mean?" suggestions
- Boundary behavior warnings for navigation tokens
- Keyboard navigation support
- Insert token at cursor position

**Implementation**:

```typescript
/**
 * Token input component with autocomplete and validation.
 * Following CLAUDE.md Rule #3: Explicit validation with meaningful errors.
 */

import React, { useState, useRef, useEffect } from 'react';
import { TokenRegistry, TokenInfo } from '@/services/tokenRegistry';
import { AlertCircle, Info, ChevronDown } from 'lucide-react';

interface TokenInputProps {
  label: string;
  value: string;
  onChange: (value: string) => void;
  placeholder?: string;
  helpText?: string;
  availableTokens: TokenInfo[];
  showAutocomplete?: boolean;
}

const TokenInput: React.FC<TokenInputProps> = ({
  label,
  value,
  onChange,
  placeholder,
  helpText,
  availableTokens,
  showAutocomplete = true
}) => {
  const [showDropdown, setShowDropdown] = useState(false);
  const [validation, setValidation] = useState<ReturnType<typeof TokenRegistry.validateToken>>({ valid: true });
  const inputRef = useRef<HTMLInputElement>(null);
  const dropdownRef = useRef<HTMLDivElement>(null);

  // Validate on value change
  useEffect(() => {
    if (value) {
      const result = TokenRegistry.validateToken(value, availableTokens);
      setValidation(result);
    } else {
      setValidation({ valid: true });
    }
  }, [value, availableTokens]);

  // Close dropdown when clicking outside
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (
        dropdownRef.current &&
        !dropdownRef.current.contains(event.target as Node) &&
        !inputRef.current?.contains(event.target as Node)
      ) {
        setShowDropdown(false);
      }
    };

    document.addEventListener('mousedown', handleClickOutside);
    return () => document.removeEventListener('mousedown', handleClickOutside);
  }, []);

  const handleInsertToken = (tokenName: string) => {
    const cursorPos = inputRef.current?.selectionStart || value.length;
    const before = value.substring(0, cursorPos);
    const after = value.substring(cursorPos);
    const newValue = `${before}{${tokenName}}${after}`;
    onChange(newValue);
    setShowDropdown(false);

    // Restore focus
    setTimeout(() => {
      inputRef.current?.focus();
      const newCursorPos = cursorPos + tokenName.length + 2;
      inputRef.current?.setSelectionRange(newCursorPos, newCursorPos);
    }, 0);
  };

  // Group tokens by category
  const tokensByCategory = availableTokens.reduce((acc, token) => {
    if (!acc[token.category]) acc[token.category] = [];
    acc[token.category].push(token);
    return acc;
  }, {} as Record<string, TokenInfo[]>);

  const categoryOrder: TokenInfo['category'][] = ['date', 'counter', 'navigation', 'rendering', 'custom'];

  return (
    <div className="space-y-1">
      <div className="flex items-center justify-between">
        <label className="block text-sm font-medium">{label}</label>
        {showAutocomplete && (
          <button
            type="button"
            onClick={() => setShowDropdown(!showDropdown)}
            className="text-xs text-blue-600 hover:text-blue-700 flex items-center gap-1"
          >
            Insert Token <ChevronDown size={12} />
          </button>
        )}
      </div>

      <div className="relative">
        <input
          ref={inputRef}
          type="text"
          value={value}
          onChange={(e) => onChange(e.target.value)}
          placeholder={placeholder}
          className={`w-full px-3 py-2 border rounded-md text-sm focus:outline-none focus:ring-1 ${
            !validation.valid
              ? 'border-red-300 focus:ring-red-500'
              : validation.warning
              ? 'border-amber-300 focus:ring-amber-500'
              : 'border-eink-pale-gray focus:ring-eink-blue'
          }`}
        />

        {/* Autocomplete Dropdown */}
        {showDropdown && showAutocomplete && (
          <div
            ref={dropdownRef}
            className="absolute z-50 mt-1 w-full max-h-96 overflow-y-auto bg-white border border-gray-300 rounded-md shadow-lg"
          >
            {categoryOrder.map(category => {
              const tokens = tokensByCategory[category];
              if (!tokens || tokens.length === 0) return null;

              return (
                <div key={category} className="border-b border-gray-200 last:border-b-0">
                  <div className="px-3 py-2 bg-gray-50 text-xs font-semibold text-gray-600 uppercase sticky top-0">
                    {category}
                  </div>
                  {tokens.map(token => (
                    <button
                      key={token.name}
                      type="button"
                      onClick={() => handleInsertToken(token.name)}
                      className="w-full px-3 py-2 text-left hover:bg-blue-50 focus:bg-blue-50 focus:outline-none"
                    >
                      <div className="flex items-start justify-between gap-2">
                        <div className="flex-1">
                          <div className="flex items-center gap-2">
                            <code className={`px-1.5 py-0.5 rounded text-xs font-mono ${TokenRegistry.getCategoryColor(token.category)}`}>
                              {'{' + token.name + '}'}
                            </code>
                            {token.hasNavigation && (
                              <span className="text-xs text-green-600">+nav</span>
                            )}
                          </div>
                          <div className="text-xs text-gray-600 mt-1">{token.description}</div>
                          {token.boundaryBehavior && (
                            <div className="text-xs text-amber-600 mt-1 flex items-start gap-1">
                              <Info size={12} className="mt-0.5 flex-shrink-0" />
                              <span>{token.boundaryBehavior}</span>
                            </div>
                          )}
                        </div>
                        <div className="text-xs text-gray-400 font-mono">{token.example}</div>
                      </div>
                    </button>
                  ))}
                </div>
              );
            })}
          </div>
        )}
      </div>

      {/* Validation Error */}
      {!validation.valid && validation.error && (
        <div className="flex items-start gap-2 text-sm text-red-600 bg-red-50 p-2 rounded border border-red-200">
          <AlertCircle size={16} className="flex-shrink-0 mt-0.5" />
          <div className="flex-1">
            <div>{validation.error}</div>
            {validation.suggestion && (
              <div className="mt-1 text-xs">
                Did you mean{' '}
                <button
                  type="button"
                  onClick={() => {
                    const tokenPattern = /\{([a-zA-Z_][a-zA-Z0-9_-]*)(:[^}]+)?\}/g;
                    const newValue = value.replace(tokenPattern, `{${validation.suggestion!.name}}`);
                    onChange(newValue);
                  }}
                  className="underline hover:text-red-700"
                >
                  {'{' + validation.suggestion.name + '}'}
                </button>
                ?
              </div>
            )}
          </div>
        </div>
      )}

      {/* Validation Warning */}
      {validation.valid && validation.warning && (
        <div className="flex items-start gap-2 text-sm text-amber-700 bg-amber-50 p-2 rounded border border-amber-200">
          <Info size={16} className="flex-shrink-0 mt-0.5" />
          <span>{validation.warning}</span>
        </div>
      )}

      {/* Help Text */}
      {helpText && !validation.error && !validation.warning && (
        <p className="text-xs text-eink-light-gray">{helpText}</p>
      )}
    </div>
  );
};

export default TokenInput;
```

**Acceptance Criteria**:
- ✅ Live validation as user types
- ✅ Clear error messages for unknown tokens
- ✅ "Did you mean?" suggestions for typos
- ✅ Warnings for boundary behavior (`_prev`/`_next`)
- ✅ Autocomplete dropdown grouped by category
- ✅ Shows navigation indicator (+nav) for tokens with auto-variants
- ✅ Keyboard navigation in dropdown
- ✅ Insert token at cursor position

**Estimated Time**: 3 hours

---

## Phase 3: Update Property Panels

**Goal**: Replace plain text inputs with TokenInput component in link/destination fields.

### Files to Modify:

#### 1. `/root/eink/frontend/src/components/editor/properties/LinkProperties.tsx`

**Changes**:
- Import `TokenInput` and `TokenRegistry`
- Get available tokens from project/section context
- Replace "Target Destination" input with `TokenInput`

**Code Changes** (lines 58-72):

```typescript
// ADD IMPORTS
import TokenInput from './shared/TokenInput';
import { TokenRegistry } from '@/services/tokenRegistry';
import { useEditorStore } from '@/stores/editorStore';

const LinkProperties: React.FC<LinkPropertiesProps> = ({ widget, onUpdate }) => {
  const properties = widget.properties || {};
  const { project } = useEditorStore() as any;

  // Get current section to determine available tokens
  // TODO: Get section configuration from project plan
  // For now, use empty counters/context (will be enhanced)
  const availableTokens = TokenRegistry.getAvailableTokens({}, {});

  // ... existing code ...

  return (
    <div className="space-y-3">
      {/* Link Text - unchanged */}
      <div>
        <label className="block text-sm font-medium mb-1">
          Link Text
        </label>
        <input
          type="text"
          value={widget.content || ''}
          onChange={(e) => updateContent(e.target.value)}
          placeholder="e.g., Next Day →, ← Previous"
          className="w-full px-3 py-2 border border-eink-pale-gray rounded-md text-sm focus:outline-none focus:ring-1 focus:ring-eink-blue"
        />
        <p className="text-xs text-eink-light-gray mt-1">
          Text that will be displayed and clickable
        </p>
      </div>

      {/* Target Destination - REPLACE with TokenInput */}
      <TokenInput
        label="Target Destination"
        value={properties.to_dest || ''}
        onChange={(value) => updateProperty('to_dest', value)}
        placeholder="e.g., day:{date_next}, month:{month}"
        helpText="Destination ID or pattern using {tokens}"
        availableTokens={availableTokens}
      />

      {/* Orientation - unchanged */}
      <SelectInput
        label="Orientation"
        value={normalizeOrientation(properties.orientation)}
        onChange={(value) => updateProperty('orientation', value)}
        options={orientationOptions}
        helpText="Text direction on the page"
      />
    </div>
  );
};
```

#### 2. `/root/eink/frontend/src/components/editor/properties/AnchorProperties.tsx`

**Changes**:
- Add `TokenInput` for `dest_id` field
- Show validation for destination ID format

#### 3. `/root/eink/frontend/src/components/editor/properties/LinkListProperties.tsx`

**Changes**:
- Add `TokenInput` for destination array editor modal
- Validate each destination entry
- Show warnings for navigation tokens in batch

**Acceptance Criteria**:
- ✅ All destination/anchor fields use TokenInput
- ✅ Autocomplete shows project-specific counters
- ✅ Validation catches typos immediately
- ✅ Warnings appear for navigation tokens

**Estimated Time**: 2 hours

---

## Phase 4: Update Documentation

**Goal**: Add navigation variable documentation to help users understand automatic behavior.

### File: `/root/eink/frontend/src/components/projects/PlanEditor.tsx`

#### Change 1: Add Navigation Variables Section to Legend (after line 1092)

```typescript
<div>
  <h4 className="font-semibold mb-3">Template Variables</h4>
  <ul className="space-y-2 text-sm">
    <li><code className="bg-gray-100 px-1 rounded">{`{year}`}</code> - Current year (2026)</li>
    <li><code className="bg-gray-100 px-1 rounded">{`{month}`}</code> - Month number (1-12)</li>
    <li><code className="bg-gray-100 px-1 rounded">{`{month:02d}`}</code> - Zero-padded month (01-12)</li>
    <li><code className="bg-gray-100 px-1 rounded">{`{month_name}`}</code> - Month name (January)</li>
    <li><code className="bg-gray-100 px-1 rounded">{`{date}`}</code> - Full date (2026-01-15)</li>
    <li><code className="bg-gray-100 px-1 rounded">{`{date_long}`}</code> - Long format (Wednesday, January 15, 2026)</li>
    <li><code className="bg-gray-100 px-1 rounded">{`{index}`}</code> - Current instance index</li>
    <li><code className="bg-gray-100 px-1 rounded">{`{index_padded}`}</code> - Zero-padded index (001, 002, ...)</li>
  </ul>

  {/* NEW: Navigation Variables Section */}
  <div className="mt-4 p-3 bg-green-50 border border-green-200 rounded">
    <h5 className="font-semibold text-green-800 mb-2">✨ Automatic Navigation Variables</h5>
    <p className="text-xs text-green-700 mb-2">
      For all counter and date variables, <code>_prev</code> and <code>_next</code> variants are automatically generated:
    </p>
    <ul className="space-y-1 text-xs text-green-700">
      <li><code className="bg-white px-1 rounded">{`{date_prev}`}</code> - Previous day (date - 1 day)</li>
      <li><code className="bg-white px-1 rounded">{`{date_next}`}</code> - Next day (date + 1 day)</li>
      <li><code className="bg-white px-1 rounded">{`{year_prev}`}</code>, <code className="bg-white px-1 rounded">{`{year_next}`}</code> - Previous/next year</li>
      <li><code className="bg-white px-1 rounded">{`{counter_prev}`}</code>, <code className="bg-white px-1 rounded">{`{counter_next}`}</code> - For any counter variable</li>
    </ul>
    <p className="text-xs text-amber-700 mt-2">
      ⚠️ Boundary behavior: <code>_prev</code> variables are empty on first page, <code>_next</code> are empty on last page
    </p>
  </div>
</div>
```

#### Change 2: Update CountersEditor Help Text (lines 1029-1032)

```typescript
{Object.keys(counters).length > 0 && (
  <div className="text-xs text-blue-600 bg-blue-50 p-2 rounded space-y-1">
    <div>
      💡 <strong>Example:</strong> Counter "page_num" with start=1, step=1 produces: 1, 2, 3, 4... for each page
    </div>
    <div className="text-green-700">
      ✨ <strong>Auto-navigation:</strong> {'{page_num_prev}'} and {'{page_num_next}'} are automatically available!
    </div>
  </div>
)}
```

**Acceptance Criteria**:
- ✅ Documentation explains automatic `_prev`/`_next` generation
- ✅ Examples show navigation variables in use
- ✅ Boundary behavior is clearly explained
- ✅ Help text updated in all relevant components

**Estimated Time**: 1 hour

---

## Phase 5: Testing Plan

**Goal**: Test with real backend, no mock data (following CLAUDE.md Rule #1).

### Test Project Structure

```json
{
  "plan": {
    "sections": [
      {
        "kind": "weeks",
        "master": "week_page",
        "generate": "count",
        "count": 52,
        "counters": {
          "week": { "start": 1, "step": 1 }
        }
      }
    ]
  }
}
```

### Test Cases

#### Test 1: Token Validation

**Input**: `day:{dat}`
**Expected**: Error message: "Unknown token: {dat}. Did you mean {date}?"
**Verify**: Red border on input, error message displayed, clickable suggestion

**Input**: `day:{date_prev}`
**Expected**: Warning message: "Empty on first page when value < start"
**Verify**: Amber border on input, warning message displayed

**Input**: `week:{week_next}`
**Expected**: Warning message: "{week_next} available on non-final pages"
**Verify**: Amber border on input, warning message displayed

#### Test 2: Autocomplete Functionality

**Action**: Click "Insert Token" button
**Expected**: Dropdown opens with categorized tokens
**Verify**:
- Categories appear in order: date, counter, navigation, rendering, custom
- Counter section shows: `week`, `week_prev`, `week_next`
- Navigation tokens show boundary warnings
- Tokens with `hasNavigation: true` show "+nav" badge

**Action**: Click `{date_next}` token
**Expected**: Token inserted at cursor position
**Verify**: Input value updates, cursor moves to after token, dropdown closes

#### Test 3: Real PDF Generation

**Setup**:
1. Create project with counter: `week` (start=1, step=1, count=52)
2. Add internal_link widget: `to_dest: "week:{week_next}"`
3. Add anchor widgets: `dest_id: "week:1"`, `week:2`, ..., `week:52`
4. Compile PDF

**Expected**:
- Week 1 link → Week 2 (link exists)
- Week 25 link → Week 26 (link exists)
- Week 52 link → (no link created, destination is empty)
- No "forward reference" errors
- No broken links in PDF

**Verify**:
- Open PDF in reader
- Test links by clicking
- Verify week 52 has no clickable link
- Check backend logs for link creation messages

#### Test 4: Boundary Conditions

**Test 4a: First Page with _prev**

**Setup**: Counter `month` (start=1, step=1, count=12)
**Widget**: `to_dest: "month:{month_prev}"`
**Expected**: Month 1 has no link (empty destination), Month 2+ link to previous month

**Test 4b: Last Page with _next**

**Setup**: Same counter as 4a
**Widget**: `to_dest: "month:{month_next}"`
**Expected**: Month 12 has no link (empty destination), Month 1-11 link to next month

**Test 4c: Date Navigation**

**Setup**: Section with `generate: "each_day"`, start: 2026-01-01, end: 2026-01-31
**Widget**: `to_dest: "day:{date_next}"`
**Expected**: Jan 31 has no link, Jan 1-30 link to next day

#### Test 5: Typo Detection

**Input**: `{weak}` (should be `{week}`)
**Expected**: "Unknown token: {weak}. Did you mean {week}?"

**Input**: `{dat_prev}` (should be `{date_prev}`)
**Expected**: "Unknown token: {dat_prev}. Did you mean {date_prev}?"

**Input**: `{mnth}` (should be `{month}`)
**Expected**: "Unknown token: {mnth}. Did you mean {month}?"

### Acceptance Criteria

- ✅ All test cases pass with real backend
- ✅ No console errors or warnings
- ✅ PDF links resolve correctly
- ✅ Boundary conditions handled gracefully (no broken links)
- ✅ Validation errors are clear and actionable
- ✅ Autocomplete improves user experience
- ✅ Documentation is accurate and helpful

**Estimated Time**: 2 hours

---

## Summary: Implementation Order

| Phase | Task | Estimated Time | Dependencies |
|-------|------|----------------|--------------|
| 1 | Create `tokenRegistry.ts` service | 2 hours | None |
| 2 | Create `TokenInput.tsx` component | 3 hours | Phase 1 |
| 3 | Update property panels | 2 hours | Phase 2 |
| 4 | Update documentation | 1 hour | None (can be parallel) |
| 5 | Testing with real backend | 2 hours | Phase 1-3 complete |

**Total Estimated Time**: 10 hours

---

## Critical Success Factors

Following CLAUDE.md standards:

1. **Rule #1 - No Dummy Implementations**:
   - All token examples are real and match backend behavior
   - No mock data in tests - use real backend
   - Complete token catalog with actual descriptions

2. **Rule #2 - No Overcomplicated Code**:
   - Simple Levenshtein distance for typo detection
   - Straightforward React hooks for UI state
   - Clear component hierarchy

3. **Rule #3 - Explicit Validation**:
   - Token validation happens as user types
   - Clear error messages with specific token names
   - Boundary warnings explain when variables are empty

4. **Rule #4 - Fail Fast**:
   - Validation errors shown immediately
   - Typo suggestions prevent mistakes
   - No silent failures - all issues visible to user

5. **Rule #5 - Challenge When Necessary**:
   - If token patterns don't match backend, raise issue
   - If validation logic differs, align with backend
   - Question any requirements that lead to poor UX

---

## Future Enhancements (Out of Scope)

These are intentionally NOT included in this plan:

1. **Live Preview**: Show example token values in real-time
2. **Context-Aware Autocomplete**: Filter tokens by section type
3. **Token Documentation Panel**: Expandable help for each token
4. **Regex Validation**: Support for complex destination patterns
5. **Token History**: Recently used tokens at top of dropdown

These can be implemented later based on user feedback.

---

## File Checklist

**New Files**:
- [ ] `/root/eink/frontend/src/services/tokenRegistry.ts`
- [ ] `/root/eink/frontend/src/components/editor/properties/shared/TokenInput.tsx`

**Modified Files**:
- [ ] `/root/eink/frontend/src/components/editor/properties/LinkProperties.tsx`
- [ ] `/root/eink/frontend/src/components/editor/properties/AnchorProperties.tsx`
- [ ] `/root/eink/frontend/src/components/editor/properties/LinkListProperties.tsx`
- [ ] `/root/eink/frontend/src/components/projects/PlanEditor.tsx`

**Test Files** (to be created):
- [ ] Test project JSON with counters
- [ ] Master templates with navigation links
- [ ] Manual test checklist

---

## Questions to Resolve Before Implementation

1. **Token Context**: How should TokenInput get section-specific counters/context?
   - Option A: Pass through props from parent component
   - Option B: Use global store/context provider
   - Option C: Fetch from project plan on mount

2. **Validation Timing**: When should validation occur?
   - Current plan: On every keystroke (live validation)
   - Alternative: On blur (less intrusive)
   - Preference: Live validation (catches errors immediately)

3. **Autocomplete Trigger**: How should users access autocomplete?
   - Current plan: "Insert Token" button + click outside to close
   - Alternative: Trigger on "{" character (like IDE)
   - Preference: Both (button for discovery, "{" for speed)

4. **Error Display**: Where should validation errors appear?
   - Current plan: Below input field (inline)
   - Alternative: Tooltip on hover
   - Preference: Inline (always visible)

---

**End of Implementation Plan**
